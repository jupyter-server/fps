{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>FPS is a Fast Pluggable System. It was originally designed to create Jupyverse, a Jupyter server that is composed of pluggins. But it is a generic framework that can be used to create any type of applications, with the following features:</p> <ul> <li>modularity: an application is made up of modules that are arranged in a hierarchical tree.</li> <li>configuration: each module can be configured with a set of parameters accessible from the CLI, and an application can be created declaratively as a Python dictionary or a JSON file.</li> <li>pluggability: modules can share objects, allowing the use of late binding to connect pluggins at runtime.</li> <li>concurrency: modules have startup and teardown phases for managing asynchronous resources safely.</li> </ul>"},{"location":"guide/","title":"Guide","text":""},{"location":"guide/#the-simplest-application","title":"The simplest application","text":"<p>Let's create our first FPS application. Enter the following code in a file called <code>simple.py</code>:</p> <pre><code>from fps import Module\n\nclass Main(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = kwargs\n\n    async def start(self):\n        print(self.config[\"greeting\"])\n\n    async def stop(self):\n        print(self.config[\"farewell\"])\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps simple:Main --set greeting=\"Hello, World!\" --set farewell=\"See you later!\"\n</code></pre> <p>This should print <code>Hello, World!</code> and hang forever, which means that the application is running. To exit, press Ctrl-C. This should now print <code>See you later!</code> and return to the terminal prompt.</p> <p>What happened?</p> <ul> <li>By entering <code>fps simple:Main</code>, we told FPS to run the module called <code>Main</code> in the <code>simple.py</code> file.</li> <li>Options <code>--set greeting=\"Hello, World!\"</code> and <code>--set farewell=\"See you later!\"</code> told FPS to pass parameter keys <code>greeting</code> and <code>farewell</code> to <code>Main.__init__</code>'s keyword arguments, with values <code>\"Hello, World!\"</code> and <code>\"See you later!\"</code>, respectively.</li> <li>In its startup phase (<code>start</code> method), <code>Main</code> prints the <code>greeting</code> parameter value.</li> <li>After starting, the application runs until it is stopped. Pressing Ctrl-C stops the application, calling its teardown phase.</li> <li>In its teardown phase (<code>stop</code> method), <code>Main</code> prints the <code>farewell</code> parameter value.</li> </ul>"},{"location":"guide/#sharing-objects-between-modules","title":"Sharing objects between modules","text":"<p>Now let's see how we can share objects between modules. Enter the following code in a file called <code>share.py</code>:</p> <pre><code>from anyio import Event, sleep\nfrom fps import Module\n\nclass Main(Module):\n    def __init__(self, name):\n        super().__init__(name)\n        self.add_module(Publisher, \"publisher\")\n        self.add_module(Consumer, \"consumer\")\n\nclass Publisher(Module):\n    async def start(self):\n        self.shared = Event()  # the object to share\n        self.put(self.shared, Event)  # publish the shared object as type Event\n        print(\"Published:\", self.shared.is_set())\n        await self.shared.wait()  # wait for the shared object to be updated\n        self.exit_app()  # force the application to exit\n\n    async def stop(self):\n        print(\"Got:\", self.shared.is_set())\n\n\nclass Consumer(Module):\n    def __init__(self, name, wait=0):\n        super().__init__(name)\n        self.wait = float(wait)\n\n    async def start(self):\n        shared = await self.get(Event)  # request an object of type Event\n        print(\"Acquired:\", shared.is_set())\n        await sleep(self.wait)  # wait before updating the shared object\n        shared.set()  # update the shared object\n        print(\"Updated:\", shared.is_set())\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps share:Main\n</code></pre> <p>You should see in the terminal: <pre><code>Published: False\nAcquired: False\nUpdated: True\nGot: True\n</code></pre></p> <p>Sharing objects between modules is based on types: a module (<code>Consumer</code>) requests an object of a given type (<code>Event</code>) with <code>await self.get</code>, and it eventually acquires it when another module (<code>Publisher</code>) publishes an object of this type with <code>self.put</code>. It is the same object that they are sharing, so if <code>Consumer</code> changes the object, <code>Publisher</code> sees it immediatly.</p> <p>The <code>Consumer</code>'s default value for parameter <code>wait</code> is 0, which means that the shared object will be updated right away. If we set it to 0.5 seconds:</p> <pre><code>fps share:Main --set consumer.wait=0.5\n</code></pre> <p>You should see that the application hangs for half a second after the shared object is acquired. This illustrate that we can configure any nested module in the application, just by providing the path to its parameter in the CLI. If we provide a wrong parameter name, we get a nice error:</p> <pre><code>fps share:Main --set consumer.wrong_parameter=0.5\n</code></pre> <pre><code>RuntimeError: Cannot instantiate module 'root_module.consumer': Consumer.__init__() got an unexpected keyword argument 'wrong_parameter'\n</code></pre>"},{"location":"guide/#a-pluggable-web-server","title":"A pluggable web server","text":"<p>FPS comes with a <code>FastAPIModule</code> that publishes a <code>FastAPI</code> application. This <code>FastAPI</code> object can be shared with other modules, which can add routes to it. As part of its startup phase, <code>FastAPIModule</code> serves the <code>FastAPI</code> application with a web server. Enter the following code in a file called <code>server.py</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fps import Module\nfrom fps.web.fastapi import FastAPIModule\nfrom pydantic import BaseModel\n\nclass Main(Module):\n    def __init__(self, name):\n        super().__init__(name)\n        self.add_module(FastAPIModule, \"fastapi\")\n        self.add_module(Router, \"router\")\n\nclass Router(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = Config(**kwargs)\n\n    async def prepare(self):\n        app = await self.get(FastAPI)\n        @app.get(\"/\")\n        def read_root():\n            return {self.config.key: self.config.value}\n\nclass Config(BaseModel):\n    key: str = \"count\"\n    value: int = 3\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps server:Main\n</code></pre> <p>Now if you open a browser at <code>http://127.0.0.1:8000</code>, you should see:</p> <pre><code>{\"count\":3}\n</code></pre> <p>Note that <code>Router</code> has a <code>prepare</code> method. It is similar to the <code>start</code> method, be it is executed just before. Typically, this is used by modules like <code>FastAPIModule</code> which must give a chance to every other module to register their routes on the <code>FastAPI</code> application, before running the server in <code>start</code>, because routes cannot be added once the server has started.</p> <p>See how <code>Router</code> uses a Pydantic model <code>Config</code> to validate its configuration. With this, running the application with a wrong type will not work:</p> <pre><code>fps main:Main --set router.value=foo\n# RuntimeError: Cannot instantiate module 'root_module.router': 1 validation error for Config\n# value\n#   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='foo', input_type=str]\n#     For further information visit https://errors.pydantic.dev/2.10/v/int_parsing\n</code></pre> <p>Jupyverse uses <code>FastAPIModule</code> in order to compose a Jupyter server from swappable pluggins.</p>"},{"location":"guide/#a-declarative-application","title":"A declarative application","text":"<p>It is possible to configure an application entirely as a Python dictionary or a JSON file. Let's rewrite the previous example in <code>router.py</code>, and just keep the code for the <code>Router</code> module:</p> <pre><code>from fastapi import FastAPI\nfrom fps import Module\nfrom pydantic import BaseModel\n\nclass Router(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = Config(**kwargs)\n\n    async def prepare(self):\n        app = await self.get(FastAPI)\n        @app.get(\"/\")\n        def read_root():\n            return {self.config.key: self.config.value}\n\nclass Config(BaseModel):\n    key: str = \"count\"\n    value: int = 3\n</code></pre> <p>Now we can write a <code>config.json</code> file like so:</p> <pre><code>{\n  \"main\": {\n    \"type\": \"fps_module\",\n    \"modules\": {\n      \"fastapi\": {\n        \"type\": \"fps.web.fastapi:FastAPIModule\"\n      },\n      \"router\": {\n        \"type\": \"router:Router\",\n        \"config\": {\n          \"value\": 7\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>And launch our application with:</p> <pre><code>fps --config config.json\n</code></pre> <p>Note that the <code>type</code> field in <code>config.json</code> can be a path to a module, like <code>fps.web.fastapi:FastAPIModule</code> or <code>router:Router</code>, or a module name registered in the <code>fps.modules</code> entry-point group, like <code>fps_module</code> which is a base FPS <code>Module</code>.</p>"},{"location":"guide/#a-note-on-concurrency","title":"A note on concurrency","text":"<p>The following <code>Module</code> methods are run as background tasks:</p> <ul> <li><code>prepare</code></li> <li><code>start</code></li> <li><code>stop</code></li> </ul> <p>FPS will consider each of them to have completed if they run to completion, or if they call <code>self.done()</code>. Let's consider the following example:</p> <pre><code>from anyio import sleep\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        await sleep(float(\"inf\"))\n</code></pre> <p>FPS will notice that this module never completes the startup phase, because its <code>start</code> method hangs indefinitely. By default, this will time out after one second. The solution is to launch a background task and then explicitly call <code>self.done()</code>, like so:</p> <pre><code>from anyio import create_task_group, sleep\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        async with create_task_group() as tg:\n            tg.start_soon(sleep, float(\"inf\"))\n            self.done()\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>FPS can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install fps[web]\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my-env</code>, and activate it: <pre><code>micromamba create -n my-env\nmicromamba activate my-env\n</code></pre> Then install <code>fps</code>.</p> <pre><code>micromamba install fps\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/fps.git\ncd fps\n</code></pre> We recommend working in a conda environment. In order to build <code>fps</code>, you will need <code>pip</code>: <pre><code>micromamba create -n fps-dev\nmicromamba activate fps-dev\nmicromamba install pip\n</code></pre> Then install <code>fps</code> in editable mode: <pre><code>pip install -e \".[web,test,docs]\"\n</code></pre></p>"}]}