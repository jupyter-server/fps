{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>FPS is a Fast Pluggable System. It was originally designed to create Jupyverse, a Jupyter server that is composed of pluggins. But it is a generic framework that can be used to create any type of applications, with the following features:</p> <ul> <li>modularity: an application is made up of modules that are arranged in a hierarchical tree.</li> <li>configuration: each module can be configured with a set of parameters accessible from the CLI, and an application can be created declaratively as a Python dictionary or a JSON file.</li> <li>pluggability: modules can share objects, allowing the use of late binding to connect pluggins at runtime.</li> <li>concurrency: modules have startup and teardown phases for managing asynchronous resources safely.</li> <li>borrow checker: shared objects are torn down until all borrowers drop their reference, avoiding the use of \"dangling\" resources.</li> </ul>"},{"location":"api_reference/","title":"API reference","text":""},{"location":"api_reference/#fps.Context","title":"<code>Context</code>","text":"<p>A context allows to share values. When a shared value is put in a context, it can be borrowed by calling <code>await context.get(value_type)</code>, where <code>value_type</code> is the type of the desired value.</p> <p>A context must be used with an async context manager. It exits after all shared values that were borrowed have been dropped. The shared values will be torn down, if applicable.</p> <p>Contexts can be nested. When a value is shared in a context, it is made available to all its children, but not its parent.</p>"},{"location":"api_reference/#fps.Context.aclose","title":"<code>aclose(*, timeout=None, _exc_type=None, _exc_value=None, _exc_tb=None)</code>  <code>async</code>","text":"<p>Close the context, after all shared values that were borrowed have been dropped. The shared values will be torn down, if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The time to wait for all shared values to be freed.</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the context could not be closed in time.</p>"},{"location":"api_reference/#fps.Context.add_teardown_callback","title":"<code>add_teardown_callback(teardown_callback)</code>","text":"<p>Register a callback that will be called at context teardown. The callbacks will be called in the inverse order than they were added.</p> <p>Parameters:</p> Name Type Description Default <code>teardown_callback</code> <code>Callable[..., Any] | Callable[..., Awaitable[Any]]</code> <p>The callback to add.</p> required"},{"location":"api_reference/#fps.Context.get","title":"<code>get(value_type, timeout=float('inf'))</code>  <code>async</code>","text":"<p>Get a value from the context, with the given type. The value will be returned if/when it is put in the context and when it accepts to be borrowed (borrowing can be limited with a maximum number of borrowers).</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>type[T]</code> <p>The type of the value to get.</p> required <code>timeout</code> <code>float</code> <p>The time to wait to get the value.</p> <code>float('inf')</code> <p>Returns:</p> Type Description <code>Value[T]</code> <p>The borrowed <code>Value</code>.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the value could not be borrowed in time.</p>"},{"location":"api_reference/#fps.Context.put","title":"<code>put(value, types=None, max_borrowers=float('inf'), manage=False, teardown_callback=None, shared_value=None)</code>","text":"<p>Put a value in the context so that it can be shared.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to put in the context.</p> required <code>types</code> <code>Iterable | Any | None</code> <p>The type(s) to register the value as. If not provided, the value type will be used.</p> <code>None</code> <code>max_borrowers</code> <code>float</code> <p>The number of times the shared value can be borrowed at the same time.</p> <code>float('inf')</code> <code>manage</code> <code>bool</code> <p>Whether to use the (async) context manager of the value for setup/teardown.</p> <code>False</code> <code>teardown_callback</code> <code>Callable[..., Any] | Callable[..., Awaitable[Any]] | None</code> <p>An optional callback to call when the context is closed.</p> <code>None</code> <p>Returns:</p> Type Description <code>SharedValue[T]</code> <p>The shared value.</p>"},{"location":"api_reference/#fps.Module","title":"<code>Module</code>","text":"<p>A module allows to:</p> <ul> <li>run services,</li> <li>share those services with other modules,</li> <li>request services from other modules.</li> </ul> <p>The services are represented by values that can be published by producers and borrowed by consumers. Consumers notify producers that their services are not used anymore by dropping the corresponding borrowed values. Producers are responsible for tearing down their services when stopping the application.</p> <p>Modules can be configured through their <code>__init__</code> method's keyword arguments. Modules have three phases:</p> <ul> <li><code>prepare</code>: called before the \"start\" phase.</li> <li><code>start</code>: called before running the application.</li> <li><code>stop</code>: called when shutting down the application.</li> </ul>"},{"location":"api_reference/#fps.Module.modules","title":"<code>modules</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>dict[str, Module]</code> <p>The modules added by the current module, as a <code>dict</code> of module name to module instance.</p>"},{"location":"api_reference/#fps.Module.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The module's name.</p>"},{"location":"api_reference/#fps.Module.parent","title":"<code>parent</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>Module | None</code> <p>The module's parent, unless this is the root module which has no parent.</p>"},{"location":"api_reference/#fps.Module.path","title":"<code>path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The module's path, as a period-separated sequence of module names.</p>"},{"location":"api_reference/#fps.Module.started","title":"<code>started</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Event</code> <p>An <code>Event</code> that is set when the module has started.</p>"},{"location":"api_reference/#fps.Module.__init__","title":"<code>__init__(name, prepare_timeout=1, start_timeout=1, stop_timeout=1, global_start_timeout=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to give to the module.</p> required <code>prepare_timeout</code> <code>float</code> <p>The time to wait (in seconds) for the \"prepare\" phase to complete.</p> <code>1</code> <code>start_timeout</code> <code>float</code> <p>The time to wait (in seconds) for the \"start\" phase to complete.</p> <code>1</code> <code>stop_timeout</code> <code>float</code> <p>The time to wait (in seconds) for the \"stop\" phase to complete.</p> <code>1</code> <code>global_start_timeout</code> <code>float | None</code> <p>The time to wait (in seconds) for the \"prepare\" and \"start\" phases to complete.</p> <code>None</code>"},{"location":"api_reference/#fps.Module.add_module","title":"<code>add_module(module_type, name, **config)</code>","text":"<p>Add a module as a child of the current module.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>type['Module'] | str</code> <p>A Module type or a string pointing to a module type.</p> required <code>name</code> <code>str</code> <p>The name to give to the module.</p> required <code>config</code> <p>The module configuration.</p> <code>{}</code>"},{"location":"api_reference/#fps.Module.add_teardown_callback","title":"<code>add_teardown_callback(teardown_callback)</code>","text":"<p>Register a callback that will be called when stopping the module. The callbacks will be called in the inverse order than they were added.</p> <p>Parameters:</p> Name Type Description Default <code>teardown_callback</code> <code>Callable[..., Any] | Callable[..., Awaitable[Any]]</code> <p>The callback to add.</p> required"},{"location":"api_reference/#fps.Module.all_freed","title":"<code>all_freed()</code>  <code>async</code>","text":"<p>Wait for all published values to be freed, meaning that all borrowers have dropped their values.</p>"},{"location":"api_reference/#fps.Module.done","title":"<code>done()</code>","text":"<p>Notify that the current phase is done. This is especially useful when launching background tasks, as otherwise the current phase would not complete: <pre><code>from anyio import create_task_group\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        async with create_task_group() as tg:\n            tg.start_toon(my_async_func)\n            tg.start_toon(other_async_func)\n            self.done()\n</code></pre></p>"},{"location":"api_reference/#fps.Module.drop","title":"<code>drop(value)</code>","text":"<p>Drop a borrowed value, meaning that this module doesn't use it anymore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to drop.</p> required"},{"location":"api_reference/#fps.Module.drop_all","title":"<code>drop_all()</code>","text":"<p>Drop all borrowed values.</p>"},{"location":"api_reference/#fps.Module.exit_app","title":"<code>exit_app()</code>","text":"<p>Force the application to exit. This can be called from any module.</p>"},{"location":"api_reference/#fps.Module.freed","title":"<code>freed(value)</code>  <code>async</code>","text":"<p>Wait for a published value to be free, meaning that all borrowers have dropped the value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to be freed.</p> required"},{"location":"api_reference/#fps.Module.get","title":"<code>get(value_type, timeout=float('inf'))</code>  <code>async</code>","text":"<p>Borrow a value from the current module's context or its parent's (if any).</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>type[T_Value]</code> <p>The type of the value to borrow.</p> required <code>timeout</code> <code>float</code> <p>The time to wait for the value to be published.</p> <code>float('inf')</code> <p>Returns:</p> Type Description <code>T_Value</code> <p>The borrowed value.</p>"},{"location":"api_reference/#fps.Module.prepare","title":"<code>prepare()</code>  <code>async</code>","text":"<p>The \"prepare\" phase occurs before the \"start\" phase.</p>"},{"location":"api_reference/#fps.Module.put","title":"<code>put(value, types=None, max_borrowers=float('inf'), teardown_callback=None, manage=False)</code>","text":"<p>Publish a value in the current module context and its parent's (if any).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T_Value</code> <p>The value to publish.</p> required <code>types</code> <code>Iterable | Any | None</code> <p>The type(s) to publish the value as. If not provided, the type is inferred from the value.</p> <code>None</code> <code>max_borrowers</code> <code>float</code> <p>The maximum number of simultaneous borrowers of the published value.</p> <code>float('inf')</code> <code>teardown_callback</code> <code>Callable[..., Any] | Callable[..., Awaitable[Any]] | None</code> <p>A callback to call when the value is torn down.</p> <code>None</code> <code>manage</code> <code>bool</code> <p>Whether to use the (async) context manager of the value for its setup/teardown.</p> <code>False</code>"},{"location":"api_reference/#fps.Module.run","title":"<code>run(backend='asyncio')</code>","text":"<p>Run the root module.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend used to run (\"asyncio\" or \"trio\").</p> <code>'asyncio'</code>"},{"location":"api_reference/#fps.Module.start","title":"<code>start()</code>  <code>async</code>","text":"<p>The \"start\" phase occurs after the \"prepare\" phase. This is usually where services are started and published as values, and other services are requested and borrowed as values.</p>"},{"location":"api_reference/#fps.Module.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>The \"stop\" phase occurs when the application is torn down.</p>"},{"location":"api_reference/#fps.SharedValue","title":"<code>SharedValue</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A value that can be shared with so-called borrowers. A borrower borrows a shared value by calling <code>await shared_value.get()</code>, which returns a <code>Value</code>. The shared value can be borrowed any number of times at the same time, unless specified by <code>max_borrowers</code>. All borrowers must drop their <code>Value</code> before the shared value can be closed. The shared value can be closed explicitly by calling <code>await shared_value.aclose()</code>, or by using an async context manager.</p>"},{"location":"api_reference/#fps.SharedValue.__init__","title":"<code>__init__(value, max_borrowers=float('inf'), manage=False, teardown_callback=None, close_timeout=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The inner value that is shared.</p> required <code>max_borrowers</code> <code>float</code> <p>The number of times the shared value can be borrowed at the same time.</p> <code>float('inf')</code> <code>manage</code> <code>bool</code> <p>Whether to use the (async) context manager of the inner value for setup/teardown.</p> <code>False</code> <code>teardown_callback</code> <code>Callable[..., Any] | Callable[..., Awaitable[Any]] | None</code> <p>The callback to call when closing the shared value.</p> <code>None</code> <code>close_timeout</code> <code>float | None</code> <p>The timeout to use when closing the shared value.</p> <code>None</code>"},{"location":"api_reference/#fps.SharedValue.aclose","title":"<code>aclose(*, timeout=None, _exc_type=None, _exc_value=None, _exc_tb=None)</code>  <code>async</code>","text":"<p>Wait for all borrowers to drop their value, and tear down the shared value.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The time to wait for all borrowers to drop their value.</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the shared value could not be closed in time.</p>"},{"location":"api_reference/#fps.SharedValue.freed","title":"<code>freed(timeout=float('inf'))</code>  <code>async</code>","text":"<p>Wait for all borrowers to drop their value.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>The time to wait for all borrowers to drop their value.</p> <code>float('inf')</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the shared value was not freed in time.</p>"},{"location":"api_reference/#fps.SharedValue.get","title":"<code>get(timeout=float('inf'))</code>  <code>async</code>","text":"<p>Borrow the shared value.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>The time to wait to borrow the shared value.</p> <code>float('inf')</code> <p>Returns:</p> Type Description <code>Value</code> <p>The borrowed value.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the value could not be borrowed in time.</p>"},{"location":"api_reference/#fps.Value","title":"<code>Value</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A <code>Value</code> can be obtained from a shared value by calling <code>await shared_value.get()</code>, and can be dropped by calling <code>value.drop()</code>. The inner value can be accessed by calling <code>value.unwrap()</code>, unless it was already dropped.</p>"},{"location":"api_reference/#fps.Value.__init__","title":"<code>__init__(shared_value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>shared_value</code> <code>SharedValue[T]</code> <p>The shared value this <code>Value</code> refers to.</p> required"},{"location":"api_reference/#fps.Value.drop","title":"<code>drop()</code>","text":"<p>Drop the value.</p>"},{"location":"api_reference/#fps.Value.unwrap","title":"<code>unwrap()</code>","text":"<p>Get the inner value that is shared.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the value was already dropped.</p> <p>Returns:</p> Type Description <code>T</code> <p>The inner value.</p>"},{"location":"api_reference/#fps.current_context","title":"<code>current_context()</code>","text":"<p>Returns:</p> Type Description <code>Context</code> <p>The current context, if any.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If there is no current context.</p>"},{"location":"api_reference/#fps.get","title":"<code>get(value_type, timeout=float('inf'))</code>  <code>async</code>","text":"<p>Get a value from the current context, with the given type. The value will be returned if/when it is put in the context and when it accepts to be borrowed (borrowing can be limited with a maximum number of borrowers).</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>type[T]</code> <p>The type of the value to get.</p> required <code>timeout</code> <code>float</code> <p>The time to wait to get the value.</p> <code>float('inf')</code> <p>Returns:</p> Type Description <code>Value[T]</code> <p>The borrowed <code>Value</code>.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the value could not be borrowed in time.</p> <code>LookupError</code> <p>If there is no current context.</p>"},{"location":"api_reference/#fps.put","title":"<code>put(value, types=None, max_borrowers=float('inf'), manage=False, teardown_callback=None)</code>","text":"<p>Put a value in the current context so that it can be shared.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to put in the context.</p> required <code>types</code> <code>Iterable | Any | None</code> <p>The type(s) to register the value as. If not provided, the value type will be used.</p> <code>None</code> <code>max_borrowers</code> <code>float</code> <p>The number of times the shared value can be borrowed at the same time.</p> <code>float('inf')</code> <code>manage</code> <code>bool</code> <p>Whether to use the (async) context manager of the value for setup/teardown.</p> <code>False</code> <code>teardown_callback</code> <code>Callable[..., Any] | Callable[..., Awaitable[Any]] | None</code> <p>An optional callback to call when the context is closed.</p> <code>None</code> <p>Returns:</p> Type Description <code>SharedValue[T]</code> <p>The shared value.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If there is no current context.</p>"},{"location":"guide/","title":"Guide","text":""},{"location":"guide/#the-simplest-application","title":"The simplest application","text":"<p>Let's create our first FPS application. Enter the following code in a file called <code>simple.py</code>:</p> <pre><code>from fps import Module\n\nclass Main(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = kwargs\n\n    async def start(self):\n        print(self.config[\"greeting\"])\n\n    async def stop(self):\n        print(self.config[\"farewell\"])\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps simple:Main --set greeting=\"Hello, World!\" --set farewell=\"See you later!\"\n</code></pre> <p>This should print <code>Hello, World!</code> and hang forever, which means that the application is running. To exit, press Ctrl-C. This should now print <code>See you later!</code> and return to the terminal prompt.</p> <p>What happened?</p> <ul> <li>By entering <code>fps simple:Main</code>, we told FPS to run the module called <code>Main</code> in the <code>simple.py</code> file.</li> <li>Options <code>--set greeting=\"Hello, World!\"</code> and <code>--set farewell=\"See you later!\"</code> told FPS to pass parameter keys <code>greeting</code> and <code>farewell</code> to <code>Main.__init__</code>'s keyword arguments, with values <code>\"Hello, World!\"</code> and <code>\"See you later!\"</code>, respectively.</li> <li>In its startup phase (<code>start</code> method), <code>Main</code> prints the <code>greeting</code> parameter value.</li> <li>After starting, the application runs until it is stopped. Pressing Ctrl-C stops the application, calling its teardown phase.</li> <li>In its teardown phase (<code>stop</code> method), <code>Main</code> prints the <code>farewell</code> parameter value.</li> </ul>"},{"location":"guide/#sharing-objects-between-modules","title":"Sharing objects between modules","text":"<p>Now let's see how we can share objects between modules. Enter the following code in a file called <code>share.py</code>:</p> <pre><code>from anyio import Event, sleep\nfrom fps import Module\n\nclass Main(Module):\n    def __init__(self, name):\n        super().__init__(name)\n        self.add_module(Publisher, \"publisher\")\n        self.add_module(Consumer, \"consumer\")\n\nclass Publisher(Module):\n    async def start(self):\n        self.shared = Event()  # the object to share\n        self.put(self.shared, Event)  # publish the shared object as type Event\n        print(\"Published:\", self.shared.is_set())\n        await self.shared.wait()  # wait for the shared object to be updated\n        self.exit_app()  # force the application to exit\n\n    async def stop(self):\n        print(\"Got:\", self.shared.is_set())\n\n\nclass Consumer(Module):\n    def __init__(self, name, wait=0):\n        super().__init__(name)\n        self.wait = float(wait)\n\n    async def start(self):\n        shared = await self.get(Event)  # request an object of type Event\n        print(\"Acquired:\", shared.is_set())\n        await sleep(self.wait)  # wait before updating the shared object\n        shared.set()  # update the shared object\n        print(\"Updated:\", shared.is_set())\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps share:Main\n</code></pre> <p>You should see in the terminal: <pre><code>Published: False\nAcquired: False\nUpdated: True\nGot: True\n</code></pre></p> <p>Sharing objects between modules is based on types: a module (<code>Consumer</code>) requests an object of a given type (<code>Event</code>) with <code>await self.get</code>, and it eventually acquires it when another module (<code>Publisher</code>) publishes an object of this type with <code>self.put</code>. It is the same object that they are sharing, so if <code>Consumer</code> changes the object, <code>Publisher</code> sees it immediatly.</p> <p>The <code>Consumer</code>'s default value for parameter <code>wait</code> is 0, which means that the shared object will be updated right away. If we set it to 0.5 seconds:</p> <pre><code>fps share:Main --set consumer.wait=0.5\n</code></pre> <p>You should see that the application hangs for half a second after the shared object is acquired. This illustrate that we can configure any nested module in the application, just by providing the path to its parameter in the CLI. If we provide a wrong parameter name, we get a nice error:</p> <pre><code>fps share:Main --set consumer.wrong_parameter=0.5\n</code></pre> <pre><code>RuntimeError: Cannot instantiate module 'root_module.consumer': Consumer.__init__() got an unexpected keyword argument 'wrong_parameter'\n</code></pre>"},{"location":"guide/#a-pluggable-web-server","title":"A pluggable web server","text":"<p>FPS comes with a <code>FastAPIModule</code> that publishes a <code>FastAPI</code> application. This <code>FastAPI</code> object can be shared with other modules, which can add routes to it. As part of its startup phase, <code>FastAPIModule</code> serves the <code>FastAPI</code> application with a web server. Enter the following code in a file called <code>server.py</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fps import Module\nfrom fps.web.fastapi import FastAPIModule\nfrom pydantic import BaseModel\n\nclass Main(Module):\n    def __init__(self, name):\n        super().__init__(name)\n        self.add_module(FastAPIModule, \"fastapi\")\n        self.add_module(Router, \"router\")\n\nclass Router(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = Config(**kwargs)\n\n    async def prepare(self):\n        app = await self.get(FastAPI)\n        @app.get(\"/\")\n        def read_root():\n            return {self.config.key: self.config.value}\n\nclass Config(BaseModel):\n    key: str = \"count\"\n    value: int = 3\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps server:Main\n</code></pre> <p>Now if you open a browser at <code>http://127.0.0.1:8000</code>, you should see:</p> <pre><code>{\"count\":3}\n</code></pre> <p>Note that <code>Router</code> has a <code>prepare</code> method. It is similar to the <code>start</code> method, be it is executed just before. Typically, this is used by modules like <code>FastAPIModule</code> which must give a chance to every other module to register their routes on the <code>FastAPI</code> application, before running the server in <code>start</code>, because routes cannot be added once the server has started.</p> <p>See how <code>Router</code> uses a Pydantic model <code>Config</code> to validate its configuration. With this, running the application with a wrong type will not work:</p> <pre><code>fps main:Main --set router.value=foo\n# RuntimeError: Cannot instantiate module 'root_module.router': 1 validation error for Config\n# value\n#   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='foo', input_type=str]\n#     For further information visit https://errors.pydantic.dev/2.10/v/int_parsing\n</code></pre> <p>Jupyverse uses <code>FastAPIModule</code> in order to compose a Jupyter server from swappable pluggins.</p>"},{"location":"guide/#a-declarative-application","title":"A declarative application","text":"<p>It is possible to configure an application entirely as a Python dictionary or a JSON file. Let's rewrite the previous example in <code>router.py</code>, and just keep the code for the <code>Router</code> module:</p> <pre><code>from fastapi import FastAPI\nfrom fps import Module\nfrom pydantic import BaseModel\n\nclass Router(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = Config(**kwargs)\n\n    async def prepare(self):\n        app = await self.get(FastAPI)\n        @app.get(\"/\")\n        def read_root():\n            return {self.config.key: self.config.value}\n\nclass Config(BaseModel):\n    key: str = \"count\"\n    value: int = 3\n</code></pre> <p>Now we can write a <code>config.json</code> file like so:</p> <pre><code>{\n  \"main\": {\n    \"type\": \"fps_module\",\n    \"modules\": {\n      \"fastapi\": {\n        \"type\": \"fps.web.fastapi:FastAPIModule\"\n      },\n      \"router\": {\n        \"type\": \"router:Router\",\n        \"config\": {\n          \"value\": 7\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>And launch our application with:</p> <pre><code>fps --config config.json\n</code></pre> <p>Note that the <code>type</code> field in <code>config.json</code> can be a path to a module, like <code>fps.web.fastapi:FastAPIModule</code> or <code>router:Router</code>, or a module name registered in the <code>fps.modules</code> entry-point group, like <code>fps_module</code> which is a base FPS <code>Module</code>.</p>"},{"location":"guide/#a-note-on-concurrency","title":"A note on concurrency","text":"<p>The following <code>Module</code> methods are run as background tasks:</p> <ul> <li><code>prepare</code></li> <li><code>start</code></li> <li><code>stop</code></li> </ul> <p>FPS will consider each of them to have completed if they run to completion, or if they call <code>self.done()</code>. Let's consider the following example:</p> <pre><code>from anyio import sleep\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        await sleep(float(\"inf\"))\n</code></pre> <p>FPS will notice that this module never completes the startup phase, because its <code>start</code> method hangs indefinitely. By default, this will time out after one second. The solution is to launch a background task and then explicitly call <code>self.done()</code>, like so:</p> <pre><code>from anyio import create_task_group, sleep\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        async with create_task_group() as tg:\n            tg.start_soon(sleep, float(\"inf\"))\n            self.done()\n</code></pre>"},{"location":"guide/#contexts","title":"Contexts","text":"<p>FPS offers a <code>Context</code> class that allows to share objects independently of modules. For instance, say you want to share a file object. Here is how you would do:</p> <pre><code>from io import TextIOWrapper\nfrom anyio import run\nfrom fps import Context\n\nasync def main():\n    async with Context() as context:\n        file = open(\"log.txt\", \"w\")\n        print(\"File opened\")\n\n        def teardown_callback():\n            file.close()\n            print(\"File closed\")\n\n        shared_file = context.put(file, teardown_callback=teardown_callback)\n        print(\"File object published\")\n        acquired_file = await context.get(TextIOWrapper)\n        print(\"File object acquired\")\n        assert acquired_file.unwrap() is file\n\n        print(\"Writing to file\")\n        acquired_file.unwrap().write(\"Hello, World!\\n\")\n        acquired_file.drop()\n        print(\"File object dropped\")\n        await shared_file.freed()\n\nrun(main)\n</code></pre> <p>Running this code will print:</p> <pre><code>File opened\nFile object published\nFile object acquired\nWriting to file\nFile object dropped\nFile closed\n</code></pre> <p>Let's see what happened: - We created an object that we want to share, here <code>file</code>. This file has to be closed eventually. - We published it in the <code>context</code>, with <code>context.put(file, teardown_callback=teardown_callback)</code>. The <code>teardown_callback</code> will be called when the context is closed. We got a <code>shared_file</code> handle that we can use to check if the object is still in use (see below). - We acquired the file object with <code>await context.get(TextIOWrapper)</code>, and we got an <code>acquired_file</code> handle that we can use to drop the object when we are done using it. Note that acquiring an object is usually done in some other part of the program, where only the <code>context</code> is available. - We write to the file using <code>acquired_file.unwrap().write(\"Hello, World!\\n\")</code>. Note that we call <code>unwrap()</code> to get the actual object, since our handle is a wrapper around the object. - We drop the file object with <code>acquired_file.drop()</code>, notifying the <code>shared_file</code> that we are done using it and that from our point of view it is safe to close it. - The publisher can check that the published file is not used anymore with <code>await shared_file.freed()</code>. - When the <code>context</code> is closed, it waits for every published object to be freed and then it proceeds with their teardown, if any.</p> <p>Contexts ensure that objects are shared safely by their \"owner\" and that they are torn down when they are not being used anymore, by keeping references of \"borrowers\". Borrowers must collaborate by explicitly dropping objects when they are done using them. Owners can explicitly check that their objects are free to be disposed, although this is optional.</p>"},{"location":"guide/#signals","title":"Signals","text":"<p>FPS offers a <code>Signal</code> class which allows one part of the code to send values that can be received in another part. One can listen to a signal by connecting a callback to it or simply by iterating values from it.</p> <p>The following code uses a callback:</p> <pre><code>from anyio import run\nfrom fps import Signal\n\nasync def main():\n    signal = Signal()\n\n    async def callback(value):\n        print(\"Received:\", value)\n\n    signal.connect(callback)\n\n    await signal.emit(\"Hello\")\n    await signal.emit(\"World!\")\n\nrun(main) \n\n# prints:\n# Received: Hello\n# Received: World!\n</code></pre> <p>And the following code uses an iterator:</p> <pre><code>from anyio import TASK_STATUS_IGNORED, create_task_group, run\nfrom anyio.abc import TaskStatus\nfrom fps import Signal\n\nasync def main():\n    signal = Signal()\n\n    async def iterate_signal(*, task_status: TaskStatus[None] = TASK_STATUS_IGNORED):\n        async with signal.iterate() as iterator:\n            task_status.started()\n            async for value in iterator:\n                if not value:\n                    return\n\n                print(\"Received:\", value)\n\n\n    async with create_task_group() as tg:\n        await tg.start(iterate_signal)\n\n        await signal.emit(\"Hello\")\n        await signal.emit(\"World!\")\n        await signal.emit(\"\")\n\nrun(main)\n\n# prints:\n# Received: Hello\n# Received: World!\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>FPS can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install fps[web]\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my-env</code>, and activate it: <pre><code>micromamba create -n my-env\nmicromamba activate my-env\n</code></pre> Then install <code>fps</code>.</p> <pre><code>micromamba install fps\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/fps.git\ncd fps\n</code></pre> We recommend working in a conda environment. In order to build <code>fps</code>, you will need <code>pip</code>: <pre><code>micromamba create -n fps-dev\nmicromamba activate fps-dev\nmicromamba install pip\n</code></pre> Then install <code>fps</code> in editable mode: <pre><code>pip install -e \".[web,test,docs]\"\n</code></pre></p>"}]}