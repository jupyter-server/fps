{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>FPS is a Fast Pluggable System. It was originally designed to create Jupyverse, a Jupyter server that is composed of pluggins. But it is a generic framework that can be used to create any type of applications, with the following features:</p> <ul> <li>modularity: an application is made up of modules that are arranged in a hierarchical tree.</li> <li>configuration: each module can be configured with a set of parameters accessible from the CLI, and an application can be created declaratively as a Python dictionary or a JSON file.</li> <li>pluggability: modules can share objects, allowing the use of late binding to connect pluggins at runtime.</li> <li>concurrency: modules have startup and teardown phases for managing asynchronous resources safely.</li> </ul>"},{"location":"guide/","title":"Guide","text":""},{"location":"guide/#the-simplest-application","title":"The simplest application","text":"<p>Let's create our first FPS application. Enter the following code in a file called <code>simple.py</code>:</p> <pre><code>from fps import Module\n\nclass Main(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = kwargs\n\n    async def start(self):\n        print(self.config[\"greeting\"])\n\n    async def stop(self):\n        print(self.config[\"farewell\"])\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps simple:Main --set greeting=\"Hello, World!\" --set farewell=\"See you later!\"\n</code></pre> <p>This should print <code>Hello, World!</code> and hang forever, which means that the application is running. To exit, press Ctrl-C. This should now print <code>See you later!</code> and return to the terminal prompt.</p> <p>What happened?</p> <ul> <li>By entering <code>fps simple:Main</code>, we told FPS to run the module called <code>Main</code> in the <code>simple.py</code> file.</li> <li>Options <code>--set greeting=\"Hello, World!\"</code> and <code>--set farewell=\"See you later!\"</code> told FPS to pass parameter keys <code>greeting</code> and <code>farewell</code> to <code>Main.__init__</code>'s keyword arguments, with values <code>\"Hello, World!\"</code> and <code>\"See you later!\"</code>, respectively.</li> <li>In its startup phase (<code>start</code> method), <code>Main</code> prints the <code>greeting</code> parameter value.</li> <li>After starting, the application runs until it is stopped. Pressing Ctrl-C stops the application, calling its teardown phase.</li> <li>In its teardown phase (<code>stop</code> method), <code>Main</code> prints the <code>farewell</code> parameter value.</li> </ul>"},{"location":"guide/#sharing-objects-between-modules","title":"Sharing objects between modules","text":"<p>Now let's see how we can share objects between modules. Enter the following code in a file called <code>share.py</code>:</p> <pre><code>from anyio import Event, sleep\nfrom fps import Module\n\nclass Main(Module):\n    def __init__(self, name):\n        super().__init__(name)\n        self.add_module(Publisher, \"publisher\")\n        self.add_module(Consumer, \"consumer\")\n\nclass Publisher(Module):\n    async def start(self):\n        self.shared = Event()  # the object to share\n        self.put(self.shared, Event)  # publish the shared object as type Event\n        print(\"Published:\", self.shared.is_set())\n        await self.shared.wait()  # wait for the shared object to be updated\n        self.exit_app()  # force the application to exit\n\n    async def stop(self):\n        print(\"Got:\", self.shared.is_set())\n\n\nclass Consumer(Module):\n    def __init__(self, name, wait=0):\n        super().__init__(name)\n        self.wait = float(wait)\n\n    async def start(self):\n        shared = await self.get(Event)  # request an object of type Event\n        print(\"Acquired:\", shared.is_set())\n        await sleep(self.wait)  # wait before updating the shared object\n        shared.set()  # update the shared object\n        print(\"Updated:\", shared.is_set())\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps share:Main\n</code></pre> <p>You should see in the terminal: <pre><code>Published: False\nAcquired: False\nUpdated: True\nGot: True\n</code></pre></p> <p>Sharing objects between modules is based on types: a module (<code>Consumer</code>) requests an object of a given type (<code>Event</code>) with <code>await self.get</code>, and it eventually acquires it when another module (<code>Publisher</code>) publishes an object of this type with <code>self.put</code>. It is the same object that they are sharing, so if <code>Consumer</code> changes the object, <code>Publisher</code> sees it immediatly.</p> <p>The <code>Consumer</code>'s default value for parameter <code>wait</code> is 0, which means that the shared object will be updated right away. If we set it to 0.5 seconds:</p> <pre><code>fps share:Main --set consumer.wait=0.5\n</code></pre> <p>You should see that the application hangs for half a second after the shared object is acquired. This illustrate that we can configure any nested module in the application, just by providing the path to its parameter in the CLI. If we provide a wrong parameter name, we get a nice error:</p> <pre><code>fps share:Main --set consumer.wrong_parameter=0.5\n</code></pre> <pre><code>RuntimeError: Cannot instantiate module 'root_module.consumer': Consumer.__init__() got an unexpected keyword argument 'wrong_parameter'\n</code></pre>"},{"location":"guide/#a-pluggable-web-server","title":"A pluggable web server","text":"<p>FPS comes with a <code>FastAPIModule</code> that publishes a <code>FastAPI</code> application. This <code>FastAPI</code> object can be shared with other modules, which can add routes to it. As part of its startup phase, <code>FastAPIModule</code> serves the <code>FastAPI</code> application with a web server. Enter the following code in a file called <code>server.py</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fps import Module\nfrom fps.web.fastapi import FastAPIModule\nfrom pydantic import BaseModel\n\nclass Main(Module):\n    def __init__(self, name):\n        super().__init__(name)\n        self.add_module(FastAPIModule, \"fastapi\")\n        self.add_module(Router, \"router\")\n\nclass Router(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = Config(**kwargs)\n\n    async def prepare(self):\n        app = await self.get(FastAPI)\n        @app.get(\"/\")\n        def read_root():\n            return {self.config.key: self.config.value}\n\nclass Config(BaseModel):\n    key: str = \"count\"\n    value: int = 3\n</code></pre> <p>And enter in the terminal:</p> <pre><code>fps server:Main\n</code></pre> <p>Now if you open a browser at <code>http://127.0.0.1:8000</code>, you should see:</p> <pre><code>{\"count\":3}\n</code></pre> <p>Note that <code>Router</code> has a <code>prepare</code> method. It is similar to the <code>start</code> method, be it is executed just before. Typically, this is used by modules like <code>FastAPIModule</code> which must give a chance to every other module to register their routes on the <code>FastAPI</code> application, before running the server in <code>start</code>, because routes cannot be added once the server has started.</p> <p>See how <code>Router</code> uses a Pydantic model <code>Config</code> to validate its configuration. With this, running the application with a wrong type will not work:</p> <pre><code>fps main:Main --set router.value=foo\n# RuntimeError: Cannot instantiate module 'root_module.router': 1 validation error for Config\n# value\n#   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='foo', input_type=str]\n#     For further information visit https://errors.pydantic.dev/2.10/v/int_parsing\n</code></pre> <p>Jupyverse uses <code>FastAPIModule</code> in order to compose a Jupyter server from swappable pluggins.</p>"},{"location":"guide/#a-declarative-application","title":"A declarative application","text":"<p>It is possible to configure an application entirely as a Python dictionary or a JSON file. Let's rewrite the previous example in <code>router.py</code>, and just keep the code for the <code>Router</code> module:</p> <pre><code>from fastapi import FastAPI\nfrom fps import Module\nfrom pydantic import BaseModel\n\nclass Router(Module):\n    def __init__(self, name, **kwargs):\n        super().__init__(name)\n        self.config = Config(**kwargs)\n\n    async def prepare(self):\n        app = await self.get(FastAPI)\n        @app.get(\"/\")\n        def read_root():\n            return {self.config.key: self.config.value}\n\nclass Config(BaseModel):\n    key: str = \"count\"\n    value: int = 3\n</code></pre> <p>Now we can write a <code>config.json</code> file like so:</p> <pre><code>{\n  \"main\": {\n    \"type\": \"fps_module\",\n    \"modules\": {\n      \"fastapi\": {\n        \"type\": \"fps.web.fastapi:FastAPIModule\"\n      },\n      \"router\": {\n        \"type\": \"router:Router\",\n        \"config\": {\n          \"value\": 7\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>And launch our application with:</p> <pre><code>fps --config config.json\n</code></pre> <p>Note that the <code>type</code> field in <code>config.json</code> can be a path to a module, like <code>fps.web.fastapi:FastAPIModule</code> or <code>router:Router</code>, or a module name registered in the <code>fps.modules</code> entry-point group, like <code>fps_module</code> which is a base FPS <code>Module</code>.</p>"},{"location":"guide/#a-note-on-concurrency","title":"A note on concurrency","text":"<p>The following <code>Module</code> methods are run as background tasks:</p> <ul> <li><code>prepare</code></li> <li><code>start</code></li> <li><code>stop</code></li> </ul> <p>FPS will consider each of them to have completed if they run to completion, or if they call <code>self.done()</code>. Let's consider the following example:</p> <pre><code>from anyio import sleep\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        await sleep(float(\"inf\"))\n</code></pre> <p>FPS will notice that this module never completes the startup phase, because its <code>start</code> method hangs indefinitely. By default, this will time out after one second. The solution is to launch a background task and then explicitly call <code>self.done()</code>, like so:</p> <pre><code>from anyio import create_task_group, sleep\nfrom fps import Module\n\nclass MyModule(Module):\n    async def start(self):\n        async with create_task_group() as tg:\n            tg.start_soon(sleep, float(\"inf\"))\n            self.done()\n</code></pre>"},{"location":"guide/#contexts","title":"Contexts","text":"<p>FPS offers a <code>Context</code> class that allows to share objects independantly of modules. For instance, say you want to share a file object. Here is how you would do:</p> <pre><code>from io import TextIOWrapper\nfrom anyio import run\nfrom fps import Context\n\nasync def main():\n    async with Context() as context:\n        file = open(\"log.txt\", \"w\")\n        print(\"File opened\")\n\n        def teardown_callback():\n            file.close()\n            print(\"File closed\")\n\n        shared_file = context.put(file, teardown_callback=teardown_callback)\n        print(\"File object published\")\n        acquired_file = await context.get(TextIOWrapper)\n        print(\"File object acquired\")\n        assert acquired_file.unwrap() is file\n\n        print(\"Writing to file\")\n        acquired_file.unwrap().write(\"Hello, World!\\n\")\n        acquired_file.drop()\n        print(\"File object dropped\")\n        await shared_file.freed()\n\nrun(main)\n</code></pre> <p>Running this code will print:</p> <pre><code>File opened\nFile object published\nFile object acquired\nWriting to file\nFile object dropped\nFile closed\n</code></pre> <p>Let's see what happened: - We created an object that we want to share, here <code>file</code>. This file has to be closed eventually. - We published it in the <code>context</code>, with <code>context.put(file, teardown_callback=teardown_callback)</code>. The <code>teardown_callback</code> will be called when the context is closed. We got a <code>shared_file</code> handle that we can use to check if the object is still in use (see below). - We acquired the file object with <code>await context.get(TextIOWrapper)</code>, and we got an <code>acquired_file</code> handle that we can use to drop the object when we are done using it. Note that acquiring an object is usually done in some other part of the program, where only the <code>context</code> is available. - We write to the file using <code>acquired_file.unwrap().write(\"Hello, World!\\n\")</code>. Note that we call <code>unwrap()</code> to get the actual object, since our handle is a wrapper around the object. - We drop the file object with <code>acquired_file.drop()</code>, notifying the <code>shared_file</code> that we are done using it and that from our point of view it is safe to close it. - The publisher can check that the published file is not used anymore with <code>await shared_file.freed()</code>. - When the <code>context</code> is closed, it waits for every published object to be freed and then it proceeds with their teardown, if any.</p> <p>Contexts ensure that objects are shared safely by their \"owner\" and that they are torn down when they are not being used anymore, by keeping references of \"borrowers\". Borrowers must collaborate by explicitly dropping objects when they are done using them. Owners can explicitly check that their objects are free to be disposed, althoug this is optional.</p>"},{"location":"guide/#signals","title":"Signals","text":"<p>FPS offers a <code>Signal</code> class which allows one part of the code to send values that can be received in another part. One can listen to a signal by connecting a callback to it or simply by iterating values from it.</p> <p>The following code uses a callback:</p> <pre><code>from anyio import run\nfrom fps import Signal\n\nasync def main():\n    signal = Signal()\n\n    async def callback(value):\n        print(\"Received:\", value)\n\n    signal.connect(callback)\n\n    await signal.emit(\"Hello\")\n    await signal.emit(\"World!\")\n\nrun(main) \n\n# prints:\n# Received: Hello\n# Received: World!\n</code></pre> <p>And the following code uses an iterator:</p> <pre><code>from anyio import TASK_STATUS_IGNORED, create_task_group, run\nfrom anyio.abc import TaskStatus\nfrom fps import Signal\n\nasync def main():\n    signal = Signal()\n\n    async def iterate_signal(*, task_status: TaskStatus[None] = TASK_STATUS_IGNORED):\n        async with signal.iterate() as iterator:\n            task_status.started()\n            async for value in iterator:\n                if not value:\n                    return\n\n                print(\"Received:\", value)\n\n\n    async with create_task_group() as tg:\n        await tg.start(iterate_signal)\n\n        await signal.emit(\"Hello\")\n        await signal.emit(\"World!\")\n        await signal.emit(\"\")\n\nrun(main)\n\n# prints:\n# Received: Hello\n# Received: World!\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>FPS can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install fps[web]\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my-env</code>, and activate it: <pre><code>micromamba create -n my-env\nmicromamba activate my-env\n</code></pre> Then install <code>fps</code>.</p> <pre><code>micromamba install fps\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/fps.git\ncd fps\n</code></pre> We recommend working in a conda environment. In order to build <code>fps</code>, you will need <code>pip</code>: <pre><code>micromamba create -n fps-dev\nmicromamba activate fps-dev\nmicromamba install pip\n</code></pre> Then install <code>fps</code> in editable mode: <pre><code>pip install -e \".[web,test,docs]\"\n</code></pre></p>"}]}